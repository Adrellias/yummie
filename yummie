#!/usr/bin/env python

import ConfigParser
import logging
from logging.handlers import RotatingFileHandler, SysLogHandler
import os
import re
import subprocess
import sys
import textwrap


class Config(ConfigParser.ConfigParser):
    def __init__(self, filename):
        ConfigParser.ConfigParser.__init__(self)
        self.read([filename])

    def getdefault(self, section, option, default=None):
        try:
            return ConfigParser.ConfigParser.get(self, section, option)
        except ConfigParser.NoOptionError:
            return default


class Yummie(object):
    _re_package = re.compile(r'(?P<package>\S+)\.' +
                             r'(?P<arch>:i[3-6]86|x86_64|noarch)')

    def __init__(self, option, config):
        self.option = option
        self.config = config

        # Setup logging
        self._setup_logging()

        # stderr of the last command
        self.errors = ''
        # List of pending package
        self.updates = []

    def _setup_logging(self):
        method = self.config.getdefault('log', 'method', 'stderr')
        logger = logging.getLogger()

        if method == 'stderr':
            logging.basicConfig(
                level=logging.DEBUG,
                format='%(asctime)s %(message)s',
            )

        elif method == 'file':
            filename = self.config.get('log', 'file.filename')
            filesize = self.config.getint('log', 'file.filesize') * 1024 ** 2
            formats = logging.Formatter('%(asctime)s %(message)s')
            handler = RotatingFileHandler(filename, maxBytes=filesize)
            handler.setLevel(logging.DEBUG)
            handler.setFormatter(formats)
            logger.addHandler(handler)

        elif method == 'syslog':
            address = self.config.getdefault('log', 'syslog.address',
                                             '/dev/log')
            facility = self.config.getdefault('log', 'syslog.facility',
                                              'daemon').lower()
            formats = logging.Formatter('yummie[%(process)d]: %(message)s')
            handler = SysLogHandler(address=address,
                                    facility=facility)
            handler.setLevel(logging.DEBUG)
            handler.setFormatter(formats)
            logger.addHandler(handler)

        else:
            raise TypeError('Invalid log method: %s' % method)

    def _package_args(self):
        args = []
        for option in self.config.options('package'):
            if option.startswith('exclude'):
                args.append('--exclude="%s"' %
                            self.config.get('package', option))
            else:
                raise ValueError('Unsupported flag in section package: %s' %
                                 option)

        return args

    def _repository_args(self):
        args = []
        for option in self.config.options('repository'):
            if option.startswith('exclude'):
                args.append('--disablerepo="%s"' %
                            self.config.get('repository', option))
            else:
                raise ValueError('Unsupported flag in section repository: %s' %
                                 option)

        return args

    def _yum(self, args=[]):
        command = [
            self.config.getdefault('bin', 'yum', '/usr/bin/yum'),
            '--color=never',
        ]
        if self.option.sudo and os.geteuid() != 0:
            sudo = self.config.getdefault('bin', 'sudo', '/usr/bin/sudo')
            command.insert(0, sudo)

        command.extend(args)

        # Debugging
        logging.debug('Running:')
        command_text = textwrap.wrap(' '.join(command))
        for x in range(0, len(command_text)):
            if x == 0:
                logging.debug(command_text[x])
            else:
                logging.debug('    ' + command_text[x])

        pipe = subprocess.Popen(command,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)

        output, self.errors = pipe.communicate()
        return pipe.returncode, output

    def check_updates(self):
        args = ['--cacheonly', '--debuglevel=%d' % (self.option.debuglevel,)]
        args.extend(self._package_args())
        args.extend(self._repository_args())
        args.append('check-update')

        returncode, output = self._yum(args)
        self.updates = []
        for line in output.splitlines():
            test = self._re_package.match(line)
            if test:
                self.updates.append((
                    test.groupdict()['package'],    # package name
                    line.split()[1],                # package version
                ))

        return returncode

    def upgrade(self, packages):
        args = ['--debuglevel=%d' % (self.option.debuglevel,)]
        args.extend(self._package_args())
        args.extend(self._repository_args())
        args.append('--obsoletes')
        args.append('-y')
        args.append('update')
        args.extend(packages)

        returncode, output = self._yum(args)
        self.updates = []
        return returncode


def run():
    import optparse

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', default='/etc/yum/yummie.conf',
        metavar='FILENAME',
        help='Configuration file (default: /etc/yum/yummie.conf)')
    parser.add_option('-d', '--debuglevel', default=-1, type='int',
        metavar='LEVEL',
        help='Debug level (default: 0)')
    parser.add_option('--sudo', default=False, action='store_true',
        help='Use sudo (default: no)')
    parser.add_option('-u', '--upgrade', default=False, action='store_true',
        help='Do upgrade (default: no)')
    parser.add_option('-v', '--verbose', default=False, action='store_true',
        help='Be verbose (default: no)')

    # Parse the command line options
    option, args = parser.parse_args()

    # Setup configuration
    config = Config(option.config)

    # Parse default options from configuration file
    if not option.debuglevel and config.has_option('yummie', 'debuglevel'):
        option.debuglevel = config.getint('yummie', 'debuglevel')
    for flag in ('sudo', 'upgrade', 'verbose'):
        if not getattr(option, flag) and config.has_option('yummie', flag):
            setattr(option, flag, config.getboolean('yummie', flag))

    # Set verbosity
    logger = logging.getLogger()
    if option.verbose:
        handler = logging.StreamHandler(sys.stdout)
        handler.setLevel(logging.DEBUG)
        logger.addHandler(handler)
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    yummie = Yummie(option, config)
    updates = yummie.check_updates()
    if updates == 0:
        logging.info('No updates')
        return 0

    elif updates == 1:
        logging.error('Checking for updates failed:')
        for line in yummie.errors.splitlines():
            logging.error(line.rstrip())
        return 1

    if yummie.updates:
        logging.info('%d packages need updating:' % len(yummie.updates))
        for update, version in sorted(yummie.updates):
            logging.debug('    %s %s' % (update, version))

    else:
        logging.info('System up to date')
        return 0

    if not option.upgrade:
        loggin.info('Skipping upgrades')
        return 0

    upgrade = yummie.upgrade([update for update, version in yummie.updates])
    if upgrade == 1:
        logging.error('There was an error doing the upgrades:')
        for line in yummie.errors.splitlines():
            logging.error(line.rstrip())
        return 1

    else:
        logging.debug('Upgrades done')
        return 0


if __name__ == '__main__':
    sys.exit(run())
